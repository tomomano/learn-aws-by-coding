[[sec_bashoutter]]
== Hands-on #6: Bashoutter

In the sixth and final hands-on session, we will create a simple web service using the serverless cloud technology we have learned so far.
Specifically, let's create a social networking service (SNS), named **Bashoutter**, where people can post their own haiku poems.
(https://en.wikipedia.org/wiki/Haiku[Haiku]
is a Japanese poetic form where it is consisted of 17 characters divided in to 5,5,7 character phrases.)
By incorporating all the technologies such as Lambda, DynamoDB, and S3, a simple yet scalable social networking service that makes full use of serverless cloud will be born.
By the end of this hands-on, we will deploy a modern-looking SNS shown in <<handson_05_bashoutter>>.

[[handson_05_bashoutter]]
."Bashoutter" SNS app we will be building in this hands-on session
image::imgs/handson-bashoutter/bashoutter.png[bashoutter, 700, align="center"]

=== Preparation

The source code for the hands-on is available on GitHub at
https://github.com/tomomano/learn-aws-by-coding/tree/main/handson/bashoutter[handson/bashoutter].

To run this hands-on, it is assumed that the preparations described in the first hands-on (<<handson_01_prep>>) have been completed.

[WARNING]
====
This hands-on exercise can be performed within the
https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc[free AWS tier].
====

=== Reading the application source code

==== API

In this application, we implement functions such as accepting haiku submissions from people, and retrieving a list of haiku from the database.
As a minimum design to realize this service, we will implement four REST APIs as shown in <<tab_handson_05_api>>.
The APIs for basic data manipulation, such as posting, browsing, and deleting haiku, are provided.
In addition, `PATCH /haiku/{item_id}` is used to "like" the haiku specified by `{item_id}`.

[[tab_handson_05_api]]
[cols="1,1"]
.Bashoutter API
|===
|`GET /haiku`
|Get a list of haiku

|`POST /haiku`
|Post a new haiku

|`PATCH /haiku/{item_id}`
|Like a haiku specified by `{item_id}`

|`DELETE /haiku/{item_id}`
|Delete the haiku specified by `{item_id}`
|===

[TIP]
====
The **Open API Specification** (OAS; formerly known as the Swagger Specification) is a description format for REST APIs.
If the API specification is written according to the OAS, you can easily generate API documentation and client applications.
https://github.com/tomomano/learn-aws-by-coding/blob/main/handson/bashoutter/specs/swagger.yml[API specification prepared for this project]
is also written according to the OAS.
For more information, see
https://swagger.io/docs/specification/about/[official Swagger documentation].
====

[[sec:bashoutter_application]]
==== Application architecture

<<handson_05_architecture>> shows an overview of the application we are creating in this hands-on.

[[handson_05_architecture]]
.Application architecture
image::imgs/handson-bashoutter/handson-05-architecture.png[hands-on 05 architecture, 600, align="center"]

The summary of the system design is as follows:

* API requests from the client are first sent to the **API Gateway** (described below), and then forwarded to the Lambda function specified by the API path.
* An independent Lambda function is defined for each API path.
* A database (powered by DynamoDB) is created to record the haiku information (author, text, submission date, etc.).
* Give each Lambda function read and write access to DynamoDB.
* Finally, we create an S3 bucket to deliver the static contents of the web page.
Clients retrive HTML, CSS and JavaScript from this bucket and the contents will be displayed on a web browser.

Now, let us take a look at the main application code
(https://github.com/tomomano/learn-aws-by-coding/blob/main/handson/bashoutter/app.py[handson/bashoutter/app.py])．

[source, python, linenums]
----
class Bashoutter(core.Stack):

    def __init__(self, scope: core.App, name: str, **kwargs) -> None:
        super().__init__(scope, name, **kwargs)

        # <1>
        # dynamoDB table to store haiku
        table = ddb.Table(
            self, "Bashoutter-Table",
            partition_key=ddb.Attribute(
                name="item_id",
                type=ddb.AttributeType.STRING
            ),
            billing_mode=ddb.BillingMode.PAY_PER_REQUEST,
            removal_policy=core.RemovalPolicy.DESTROY
        )

        # <2>
        bucket = s3.Bucket(
            self, "Bashoutter-Bucket",
            website_index_document="index.html",
            public_read_access=True,
            removal_policy=core.RemovalPolicy.DESTROY
        )
        s3_deploy.BucketDeployment(
            self, "BucketDeployment",
            destination_bucket=bucket,
            sources=[s3_deploy.Source.asset("./gui/dist")],
            retain_on_delete=False,
        )

        common_params = {
            "runtime": _lambda.Runtime.PYTHON_3_7,
            "environment": {
                "TABLE_NAME": table.table_name
            }
        }

        # <3>
        # define Lambda functions
        get_haiku_lambda = _lambda.Function(
            self, "GetHaiku",
            code=_lambda.Code.from_asset("api"),
            handler="api.get_haiku",
            memory_size=512,
            **common_params,
        )
        post_haiku_lambda = _lambda.Function(
            self, "PostHaiku",
            code=_lambda.Code.from_asset("api"),
            handler="api.post_haiku",
            **common_params,
        )
        patch_haiku_lambda = _lambda.Function(
            self, "PatchHaiku",
            code=_lambda.Code.from_asset("api"),
            handler="api.patch_haiku",
            **common_params,
        )
        delete_haiku_lambda = _lambda.Function(
            self, "DeleteHaiku",
            code=_lambda.Code.from_asset("api"),
            handler="api.delete_haiku",
            **common_params,
        )

        # <4>
        # grant permissions
        table.grant_read_data(get_haiku_lambda)
        table.grant_read_write_data(post_haiku_lambda)
        table.grant_read_write_data(patch_haiku_lambda)
        table.grant_read_write_data(delete_haiku_lambda)

        # <5>
        # define API Gateway
        api = apigw.RestApi(
            self, "BashoutterApi",
            default_cors_preflight_options=apigw.CorsOptions(
                allow_origins=apigw.Cors.ALL_ORIGINS,
                allow_methods=apigw.Cors.ALL_METHODS,
            )
        )

        haiku = api.root.add_resource("haiku")
        haiku.add_method(
            "GET",
            apigw.LambdaIntegration(get_haiku_lambda)
        )
        haiku.add_method(
            "POST",
            apigw.LambdaIntegration(post_haiku_lambda)
        )

        haiku_item_id = haiku.add_resource("{item_id}")
        haiku_item_id.add_method(
            "PATCH",
            apigw.LambdaIntegration(patch_haiku_lambda)
        )
        haiku_item_id.add_method(
            "DELETE",
            apigw.LambdaIntegration(delete_haiku_lambda)
        )
----

<1> Here, a DynamoDB table is created to record the haiku information.
<2> This part creates an S3 bucket to store and deliver the static site contents.
`s3_deploy.BucketDeployment()` configures the settings to automatically upload the necessary files when the stack is deployed.
<3> This part defines the Lambda functions to be executed by each API path.
The functions are written in Python 3.7 and the code can be found at
https://github.com/tomomano/learn-aws-by-coding/blob/main/handson/bashoutter/api/api.py[handson/bashoutter/api/api.py].
<4> The Lambda function defined in <3> is given read and write access to the database.
<5> Here, the API Gateway is used to link each API path with the corresponding Lambda function.

==== S3 bucket in Public access mode

Take a closer look at the part of the code where an S3 bucket is created.

[source, python, linenums]
----
bucket = s3.Bucket(
    self, "Bashoutter-Bucket",
    website_index_document="index.html",
    public_read_access=True,
    removal_policy=core.RemovalPolicy.DESTROY
)
----

What you should pay attention to here is the line `public_read_access=True`.
S3 has a feature called **Public access mode**.
When the public access mode is turned on, the files in the bucket can be viewed without authentication (i.e., by anyone on the Internet).
This setting is ideal for storing static content for public websites, and many serverless web services are designed this way.
When the public access mode is set, a unique URL such as `http://XXXX.s3-website-ap-northeast-1.amazonaws.com/` is assigned to the bucket.
When a client accesses this URL, `index.html` in the bucket is returned to the client, and the page is loaded
(Note that we are specifying which file to be returned in the line `website_index_document="index.html"`.)

[TIP]
====
When operating a web site for production, it is common to add the service called
https://aws.amazon.com/cloudfront/[CloudFront]
to the S3 bucket in public access mode.
CloudFront can be used to configure **Content Delivery Nework (CDN)** and encrypted HTTPS communication.
For more information about CloudFront, please refer to
https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html[official documentation "What is Amazon CloudFront?].

In this hands-on session, CloudFront configuration was not performed to simplify the code, but readers who are interested may find the program at the following link helpful.

* https://github.com/aws-samples/aws-cdk-examples/tree/master/typescript/static-site
====

[TIP]
====
The public S3 bucket is assigned a random URL by AWS.
If you want to host it in your own domain such as `example.com`, you can configure Domain Name System (DNS), such as Amazon Route 53, and add an appropriate record.
====

After creating an S3 bucket in public access mode, the following code is used to upload the website contents to the bucket upon deployment of the stack.

[source, python, linenums]
----
s3_deploy.BucketDeployment(
    self, "BucketDeployment",
    destination_bucket=bucket,
    sources=[s3_deploy.Source.asset("./gui/dist")],
    retain_on_delete=False,
)
----

With this code, the files in the directory `./gui/dist` will be placed in the bucket when the deployment is started.
The directory `./gui/dist` contains the static contents (HTML/CSS/JavaScript) of the website.
We will not explain the implementation details of the GUI here, but the code can be found at
https://github.com/tomomano/learn-aws-by-coding/tree/main/handson/bashoutter/gui[handson/bashoutter/gui].
If you are interested, we recommend to read the source code.

[TIP]
====
This website was built using the UI frameworks called
https://vuejs.org/[Vue.js]
and
https://vuetifyjs.com/[Vuetify].
By using Vue, the web page is rendered using single page application (SPA) technology.
====

==== API handler functions

When an API request comes, the function that performs the requested processing is called the handler function.
Let's take a look at the part where the handler function for the `GET /haiku` API is defined in Lambda.

[source, python, linenums]
----
get_haiku_lambda = _lambda.Function(
    self, "GetHaiku",
    code=_lambda.Code.from_asset("api"),
    handler="api.get_haiku",
    memory_size=512,
    **common_params
)
----

Starting from the simplest part, `memory_size=512` specifies the memory allocated for this function as 512MB.
`code=_lambda.Code.from_asset("api")` defines that the source code of the function should be retrieved from an external directory named `api/`.
Then, the line `handler="api.get_haiku"` specifies that `get_haiku()` function from `api.py` should be executed as a handler function.

Next, let's look at the source code of `get_haiku()` function in `api.py`
(https://github.com/tomomano/learn-aws-by-coding/blob/main/handson/bashoutter/api/api.py[handson/bashoutter/api/api.py])．

[source, python, linenums]
----
ddb = boto3.resource("dynamodb")
table = ddb.Table(os.environ["TABLE_NAME"])

def get_haiku(event, context):
    """
    handler for GET /haiku
    """
    try:
        response = table.scan()

        status_code = 200
        resp = response.get("Items")
    except Exception as e:
        status_code = 500
        resp = {"description": f"Internal server error. {str(e)}"}
    return {
        "statusCode": status_code,
        "headers": HEADERS,
        "body": json.dumps(resp, cls=DecimalEncoder)
    }
----

In the line `response = table.scan()`, all the elements are retrieved from the DynamoDB table.
If no error occurs, the status code 200 is returned along with the haiku data, and if any error occurs, the status code 500 is returned.

By repeating the above operations for other APIs, handler functions for all APIs are defined.

[TIP]
====
In the handler function of `GET /haiku`, notice the line `response = table.scan()`.
This is actually not the best way to write a data retrieval from DynamoDB.
The `scan()` method of DynamoDB returns only data up to 1MB in size.
If the size of the data in the database is larger than 1MB, you need to call the `scan()` method recursively.
For more information, refer to
https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/dynamodb.html#DynamoDB.Table.scan[the official documentation of boto3 library].
====

[[sec:bashoutter_iam]]
==== Identity and Access Management (IAM)

Look at the following part of the code.

[source, python, linenums]
----
table.grant_read_data(get_haiku_lambda)
table.grant_read_write_data(post_haiku_lambda)
table.grant_read_write_data(patch_haiku_lambda)
table.grant_read_write_data(delete_haiku_lambda)
----

AWS has an important concept called
https://aws.amazon.com/iam/[IAM (Identity and Access Management)].
Although we have not mentioned it so far for the sake of simplicity, IAM is a very important concept in designing the cloud system on AWS.
IAM basically defines what permissions a resource has over other resources.
For example, in its default state, Lambda does not have any permissions to access other resources such as DynamoDB.
Therefore, in order for a Lambda function to read or write DynamoDB data, an IAM must be granted to the Lambda function to allow such operation.

`dynamodb.Table` object in CDK has a convenient method `grant_read_write_data()`, which assigns IAM to other resources so that they can perform read and write operation to the database.
Similarly, the `s3.Bucket` object in CDK has a method `grant_read_write()` to allow reading and writing to the bucket.
Indeed, we used this method in <<sec_aws_batch>> where we granted AWS Batch to write data to S3 bucket.
Interested readers can look back and check the code.

[NOTE]
====
The best practice to manage IAM is that the minimam permissions necessary for the system to work should be assigned to each resource.
This will not only improve security of the system, but also reduce bugs by, for example, preventing unintended resources from reading or writing to the database.
For this reason, the above code grants only read permission to the handler of `GET /haiku` API (notice the use of `grant_read_data()` method instead of `grant_read_write_data()`).
====

==== API Gateway

https://aws.amazon.com/api-gateway/[API Gateway] is literally an gateway that forwards API requests to Lambda, EC2, and other resources according to the API request path (<<fig:bashoutter_api_ gateway>>).
Then, the outputs of the processing performed by Lambda and EC2 are returned to the client via API Gateway.
In cloud terminology, the server that stands between the client and the backend server whose job is to forward the connection according to the API path is called a **router** or a **reverse proxy**.
Traditionally, routers are usually served by a dedicated virtual server.
API Gateway, on the other hand, is a serverless router service where it achieves routing without a fixed server.
API Gateway is dynamically launched only when the API request arrives.
As a natural consequence of being serverless, it has the ability to automatically increase its routing capacity as the number of accesses increases.

[[fig:bashoutter_api_gateway]]
.API Gateway
image::imgs/handson-bashoutter/api_gateway.png[api_gateway, 700, align="center"]

By deploying an API Gateway, one can easily build a system that can handle a large number of API requests (thousands to tens of thousands per second) without having to write codes.
The summary of the API Gateway cost is shown in <<tab_handson_05_apigateway_price>>.
API Gateway also offers free tier, so up to one million requests per month can be used for free.

[[tab_handson_05_apigateway_price]]
[cols="1,1", options="header"]
.Pricing of API Gateway
|===
|Number of Requests (per month)
|Price (per million)

|First 333 million
|$4.25

|Next 667 million
|$3.53

|Next 19 billion
|$3.00
|Over 20 billion
|$1.91
|===

Let's look at the source code.

[source, python, linenums]
----
# <1>
api = apigw.RestApi(
    self, "BashoutterApi",
    default_cors_preflight_options=apigw.CorsOptions(
        allow_origins=apigw.Cors.ALL_ORIGINS,
        allow_methods=apigw.Cors.ALL_METHODS,
    )
)

# <2>
haiku = api.root.add_resource("haiku")
# <3>
haiku.add_method(
    "GET",
    apigw.LambdaIntegration(get_haiku_lambda)
)
haiku.add_method(
    "POST",
    apigw.LambdaIntegration(post_haiku_lambda)
)

# <4>
haiku_item_id = haiku.add_resource("{item_id}")
# <5>
haiku_item_id.add_method(
    "PATCH",
    apigw.LambdaIntegration(patch_haiku_lambda)
)
haiku_item_id.add_method(
    "DELETE",
    apigw.LambdaIntegration(delete_haiku_lambda)
)
----

<1> First, an empty API Gateway is created by `api = apigw.RestApi()`.
<2> Next, we add add the API path `/haiku` by calling the method `api.root.add_resource()`.
<3> Next, `add_method()` is called to define the `GET` and `POST` methods for the `/haiku` path.
<4> Similarly, `haiku.add_resource("{item_id}")` adds the API path `/haiku/{item_id}`.
<5> Finally, `add_method()` is used to define `PATCH` and `DELETE` methods in the path `/haiku/{item_id}`.

As you can see, the API Gateway is very simple to use.
All you need to do is to sequentially describe the API path and the methods that will be executed.
